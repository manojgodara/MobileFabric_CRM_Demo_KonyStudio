/**
 * Kony namespace
 * @namespace kony
 */
if (typeof(kony) === "undefined") {
	kony = {};
}

/**
 * Constructor for creating the MBaaS client instance.
 * @class
 * @classdesc MBaaS Class
 * @memberof kony
 */
kony.mbaas = function () {
	this.mainRef = {};
	this.tokens = {};
	this.currentClaimToken = null;
	this.currentBackEndToken = null;
	var localDataStore = new mbaasDataStore();
	this.getDataStore = function(){
		return localDataStore;
	}
	this.setDataStore = function(dataStore){
		localDataStore = dataStore; 
	}
}

kony.mbaas.isDebugEnabled = true;
kony.mbaas.isInitialized = false;
kony.mbaas.currentInstance = null;

kony.mbaas.getCurrentInstance = function(){
	return kony.mbaas.currentInstance;
}


/**
 * Init success callback method.
 * @callback initSuccessCallback
 * @param {json} mainRef - Application Configuration
 */

 /**
 * Init failure callback method.
 * @callback initFailureCallback
 */
 
/**
 * Initialization method for the MBaaS SDK.
 * This method will fetch the app configuration from the MBaaS server and stores in memory.
 * This method has to be invoked before invoking any other SDK methods.
 * @param {string} appKey - Appkey of the MBaaS application
 * @param {string} appSecret - App Secret of the MBaaS application
 * @param {string} serviceUrl - URL of the MBaaS Server
 * @param {initSuccessCallback} successCallback  - Callback method on success
 * @param {initFailureCallback} failureCallback - Callback method on failure
 */
kony.mbaas.prototype.init = function (appKey, appSecret, serviceUrl, successCallback, failureCallback) {
	var logger = new mbaasLogger();
	if (!(appKey && appSecret && serviceUrl)) {
		logger.log("### init:: Invalid credentials passed");
		kony.mbaas.verifyAndCallClosure(failureCallback, "Invalid initialization parameters passed. Please check appKey, appSecret and ServiceUrl parameters");
		return;
	}
	var networkProvider = new mbaasNetworkProvider();
	this.mainRef.appKey = appKey;
	this.mainRef.appSecret = appSecret;
	serviceUrl = serviceUrl.trim();
	this.mainRef.serviceUrl = serviceUrl;
	kony.mbaas.currentInstance = this;
	var mbaasRef = this;

	var _doInit = function (serviceDoc) {
		var _processServiceDoc = function (servConfig) {
			logger.log("### init::_doInit::_processServiceDoc" + JSON.stringify(servConfig));
			try {
				mbaasRef.mainRef.appId = servConfig.appId;
				mbaasRef.mainRef.baseId = servConfig.baseId;
				mbaasRef.mainRef.name = servConfig.name;
				if (typeof(servConfig.login) !== 'undefined') {
					logger.log("### init::_doInit::_processServiceDoc parsing AuthServices");
					mbaasRef.login = servConfig.login;
				}

				if (typeof(servConfig.integsvc) !== 'undefined') {
					logger.log("### init::_doInit::_processServiceDoc parsing Integration services");
					mbaasRef.integsvc = servConfig.integsvc;
					logger.log("### init::_doInit::mbaasRef integration Services" + JSON.stringify(mbaasRef.integsvc));
				}

				if (typeof(servConfig.messagingsvc) !== 'undefined') {
					logger.log("### init::_doInit::_processServiceDoc parsing Messaging services");
					mbaasRef.messagingsvc = servConfig.messagingsvc;
				}
				
				if(typeof(servConfig.sync) !== 'undefined'){
					mbaasRef.sync = servConfig.sync;
				}
				if(typeof(servConfig.reportingsvc) !== 'undefined'){
					mbaasRef.customReportingURL = servConfig.reportingsvc.custom;
					mbaasRef.sessionReportingURL = servConfig.reportingsvc.session;
				}
				
				logger.log("### init::_doInit::_processServiceDoc parsing service document done");
				return true;
			} catch (err) {
				logger.log("### init::_doInit::_processServiceDoc failed with an exception: " + err);
				return ("processing the ServiceDoc failed with an exception: " + JSON.stringify(err));
			}
		};

		if (serviceDoc) {
			var processServiceDocResult = _processServiceDoc(serviceDoc);
			if (processServiceDocResult === true) {
				logger.log("### init::_doInit processing Service doc successful. Calling success callback");
				//TODO write similiar methods for Kony SDK and plain js
				kony.mbaas.isInitialized = true;
				kony.mbaas.initiateSession();
				kony.mbaas.verifyAndCallClosure(successCallback,mbaasRef.mainRef);
			} else {
				logger.log("### init::_doInit processing Service doc failed. Calling failure callback");
				kony.mbaas.verifyAndCallClosure(failureCallback,processServiceDocResult);
			}
		} else {
			logger.log("### init::_doInit calling GET on appConfig to retrieve servicedoc");
			networkProvider.post(
				serviceUrl,
				undefined, {
				"X-Kony-App-Key" : appKey,
				"X-Kony-App-Secret" : appSecret,
				"X-HTTP-Method-Override" : "GET"
			},
				function (data) {
				logger.log("### init::_doInit fetched servicedoc successfuly");
				logger.log("### init:: retrieved data from service doc");
				logger.log(data);
				mbaasRef.mainRef.config = data;
				mbaasRef.servicedoc = data;
				mbaasRef.mainRef.appId = data.appId;
				var processServiceDocResult = _processServiceDoc(data);
				if (processServiceDocResult === true) {
					logger.log("### init::_doInit processing service document successful");
					var svcDataStr = JSON.stringify(data);
					logger.log("### init::_doInit saving done. Calling success callback");
					kony.mbaas.isInitialized = true;
					kony.mbaas.initiateSession(mbaasRef);
					kony.mbaas.verifyAndCallClosure(successCallback, mbaasRef.mainRef);
				} else {
					logger.log("### init::_doInit processing servicedoc failed. Calling failure callback");
					kony.mbaas.verifyAndCallClosure(failureCallback,processServiceDocResult);
				}
			},
				function (data) {
				logger.log("### init::_doInit fetching service document from Server failed" + data);
				logger.log("### init::_doInit calling failure callback");
				kony.mbaas.verifyAndCallClosure(failureCallback, "fetching service document from Server failed" + data);
			});
		}

	};
		logger.log("### init::calling simple _doInit ");
		_doInit();
}
/**
 * Method to create the Identity service instance with the provided provider name.
 * @param {string} providerName - Name of the provider
 * @returns {IdentityService} Identity service instance
 */
kony.mbaas.prototype.getIdentityService = function (providerName) {
			if(!kony.mbaas.isInitialized){
				throw new Exception(Errors.INIT_FAILURE, "Please call init before invoking this service");
			}
			var logger = new mbaasLogger();
			var provider = null;
			if(this.login != null){
				for (var i = 0; i < this.login.length; i++) {
					var rec = this.login[i];
					if(rec.prov === providerName){
						this.rec = rec;
						provider = new IdentityService(this);
						break;						
					}
						
				}
			if(provider === null){
				throw new Exception(Errors.AUTH_FAILURE, "Invalid providerName");
			}
			//TODO: what if the providerName is not passed by the user? 
			logger.log("### auth:: returning authService for providerName = " + provider.getProviderName());
			return provider;			
			}

		}; 
/**
 * Should not be called by the developer.
 * @class
 * @classdesc Identity service instance for handling login/logout calls.
 */
function IdentityService(mbaasRef){
			var logger = new mbaasLogger();
			var networkProvider = new mbaasNetworkProvider();
			var serviceObj = mbaasRef.rec;
			var mainRef = mbaasRef.mainRef;
			if (serviceObj === undefined || serviceObj.prov == undefined || serviceObj.type == undefined) {
				throw new Exception(Errors.INIT_FAILURE, "Invalid service url and service type");
			}

			var _type = serviceObj.type;
			var _serviceUrl = stripTrailingCharacter(serviceObj.url, "/"); ;
			var _providerName = serviceObj.prov;

			logger.log("### AuthService:: initialized for provider " + _providerName + " with type " + _type);

			var dsKey = _serviceUrl + "::" + _providerName + "::" + _type + "::RAW";
			/**
			* Login success callback method.
			* @callback loginSuccessCallback
			* @param {string} claimsToken - Claims token value
			*/

			/**
			* Login failure callback method.
			* @callback loginFailureCallback
			* @param {json} error - Error information
			*/
			/**
			 * Login with the given credentials asynchronously and executes the given callback.
			 * @param {object} options - User name and password
			 * @param {loginSuccessCallback} successCallback  - Callback method on success
			 * @param {loginFailureCallback} failureCallback - Callback method on failure
			 */
			this.login = function (options, successCallback, failureCallback) {

				logger.log("### AuthService::login Invoked login for provider " + _providerName + " of type " + _type);

				if (typeof(options) == 'undefined') {
					throw new Exception(Errors.INIT_FAILURE, "Missing required number of arguments to login function");
				}
				function invokeAjaxCall(url, params) {
					networkProvider.post(_serviceUrl + url + "?provider=" + _providerName, params, {
						"X-Kony-App-Key" : mainRef.appKey,
						"X-Kony-App-Secret" : mainRef.appSecret
					},
						function (data) {
						logger.log("### AuthService::login successful. Retrieved Data:: ");
						logger.log(data);
						mbaasRef.tokens[_providerName] = data;
						logger.log("### AuthService::login extracted token. Calling success callback");
						mbaasRef.currentClaimToken = data.claims_token.value;
						mbaasRef.currentBackEndToken = data.provider_token;
						kony.mbaas.verifyAndCallClosure(successCallback, data.claims_token.value);
					},
						function (data) {
						logger.log("### AuthService::login login failure. retrieved data:: ");
						logger.log(data);
						logger.log("### AuthService::login Calling failure callback");
						failureCallback(data);
					});
				}
				//TODO: error handling for oauth2 and saml
				if (_type == "oauth2") {
					logger.log("### AuthService::login Adapter type is oauth2");
					
					OAuthHandler(_serviceUrl, _providerName, invokeAjaxCall,"/oauth2/token");

				} else if (_type == "basic") {

					if (options.userid == undefined || options.password == undefined) {
						throw new Exception(Errors.INIT_FAILURE, "Require username and password");
					}
					
					logger.log("### AuthService::login Adapter type is basic ");
					invokeAjaxCall("/login",{
						"userid" : options.userid,
						"password" : options.password,
						"provider" : _providerName
					});
				} else if (_type === "saml"){
					logger.log("### AuthService::login Adapter type is saml");
					OAuthHandler(_serviceUrl, _providerName, invokeAjaxCall,"/saml/token");
				
				}
			};
			/**
			* Logout success callback method.
			* @callback logoutSuccessCallback
			*/

			/**
			* Logout failure callback method.
			* @callback logoutFailureCallback
			*/
			/**
			 * Logout and executes the given callback.
			 * @param {logoutSuccessCallback} successCallback  - Callback method on success
			 * @param {logoutFailureCallback} failureCallback - Callback method on failure
			 */
			this.logout = function (successCallback, failureCallback) {
				logger.log("### AuthService::logout invoked on provider " + _providerName + " of type " + _type);
				var value = mbaasRef.tokens[_providerName];
				var claimsToken = value.claims_token.value;
	
				delete mbaasRef.tokens[_providerName];

				//FIXME: currently logout gives empty text response which results in failure even in good case
				networkProvider.post(_serviceUrl + "/logout", {}, {
					"Authorization" : claimsToken
				},
					function (data) {
					logger.log("AuthService::logout successfully logged out. Calling success callback");
					kony.mbaas.verifyAndCallClosure(successCallback, {});
				},
					function (xhr, status, err) {
					if (xhr.status == 200) {
						logger.log("### AuthService::logout successfully logged out. Calling success callback");
						kony.mbaas.verifyAndCallClosure(successCallback, {});
					} else {
						logger.log("### AuthService::logout logged out Failed. Calling failure callback");
						kony.mbaas.verifyAndCallClosure(failureCallback, {});
					}
				});
			};
			/**
			 * Option to change password. Not implemented in other platforms hence marking as private
			 * @private
			 */
			this.changePassword = function (options, successCallback, failureCallback) {
				if (options == undefined || options.old_password == undefined || options.new_password == undefined) {
					throw new Exception(Errors.INIT_FAILURE, "Missing required arguments");
				} else {
					if (mbaasRef.tokens[_providerName]) {
						var rawToken = mbaasRef.tokens[_providerName];
						var val = JSON.parse(rawToken);
						var refreshToken = val.refresh_token;

						var data = {
							"old_password" : options.old_password,
							"new_password" : options.new_password
						};

						networkProvider.post(_serviceUrl + "/change_password",
							data, {
							"Authorization" : val.claims_token.value,
							"Content-Type" : "application/x-www-form-urlencoded"
						},
							successCallback,
							failureCallback);

					} else {
						failureCallback(null);
					}
				}
			};
			/**
			* Fetch claims token callback method.
			* @callback fetchClaimsTokenSuccessCallback
			* @param {string} claimsToken - Claims token value
			*/

			/**
			* Fetch claims token callback method.
			* @callback fetchClaimsTokenFailureCallback
			* @param {json} error - Error information
			*/
			/**
			 * Fetch the claims token.
			 * @param {boolean} fromserver - Flag to force fetch from server only.
			 * @param {fetchClaimsTokenSuccessCallback} successCallback  - Callback method on success
			 * @param {fetchClaimsTokenFailureCallback} failureCallback - Callback method on failure
			 * @private 
			 */
			this.getToken = function (fromserver, successCallback, failureCallback) {
				logger.log("### AuthService::getToken invoked for provider " + _providerName + " of type " + _type);
				if (fromserver === true) {
					logger.log("### AuthService::getToken fetching token from server");
					_claimsRefresh(null,
						function (token) {
						mbaasRef.tokens[_providerName] = token;
						mbaasRef.currentClaimToken = token.claims_token.value;
						kony.mbaas.verifyAndCallClosure(successCallback, token.claims_token.value);
					},
						function (err) {
						kony.mbaas.verifyAndCallClosure(failureCallback, err);
					});
				} else {
					logger.log("### AuthService::getToken Fetching token locally");
					if (mbaasRef.tokens[_providerName]) {
						var val = mbaasRef.tokens[_providerName];
						

						var _exp = val.claims_token.exp;
						if (_exp && _exp > (new Date().getTime())) {
							logger.log("### AuthService::getToken token is still valid.");
							logger.log("### AuthService::getToken extracting token successfull. calling success callback");
							mbaasRef.currentClaimToken = val.claims_token.value;
							kony.mbaas.verifyAndCallClosure(successCallback, val.claims_token.value);
						} else {
							logger.log("### AuthService::getToken token is expired. Fetching from server");
							_claimsRefresh(null,
								function (token) {
								//TODO: need to test this flow.
								logger.log("### AuthService::getToken fetching token from server successfull");
								mbaasRef.tokens[_providerName] = val.claims_token.value;
								logger.log("### AuthService::getToken extracting token successfull. calling success callback");
								kony.mbaas.verifyAndCallClosure(successCallback, token);
							},
								function (error) {
								logger.log("### AuthService::getToken Calling failure callback. fetching token from server failed with response " + error);
								kony.mbaas.verifyAndCallClosure(failureCallback, error);
							});
						}
					} else {
						logger.log("### AuthService::getToken Calling failure callback. No token info found in localstore with key " + dsKey);
						return kony.mbaas.verifyAndCallClosure(failureCallback, null);
					}
				}
			};
			/**
			* Fetch backend token callback method.
			* @callback fetchBackendTokenSuccessCallback
			* @param {string} providerToken - Provider token value
			*/

			/**
			* Fetch backend token callback method.
			* @callback fetchBackendTokenFailureCallback
			* @param {json} error - Error information
			*/
			/**
			 * Fetch the backend datasource token.
			 * @param {boolean} fromserver - Flag to force fetch from server only.
			 * @param {object} options - Options
			 * @param {fetchBackendTokenSuccessCallback} successCallback  - Callback method on success
			 * @param {fetchBackendTokenFailureCallback} failureCallback - Callback method on failure
			 */
			this.getBackendToken = function (fromserver, options, successCallback, failureCallback) {
				logger.log("### AuthService::getBackendToken called for provider " + _providerName + " of type " + _type);
				if (fromserver != undefined && fromserver === true) {
					logger.log("### AuthService::getBackendToken fromserver is enabled. Trying to login");
					_claimsRefresh(null,
						function (token) {
						mbaasRef.tokens[_providerName] = token;
						mbaasRef.currentBackEndToken = token.provider_token;
						kony.mbaas.verifyAndCallClosure(successCallback, token.provider_token);
					},
						failureCallback);
				} else {
					if (mbaasRef.tokens[_providerName]) {
						var val = mbaasRef.tokens[_providerName];
						var _exp = val.provider_token.exp;
						logger.log("token expiry time: " + _exp);
						logger.log("Current time: " + (new Date().getTime()));
						if (_exp && _exp < (new Date().getTime())) {
							logger.log("### AuthService::getBackendToken Token expired. Fetching refresh from claims api");
							_claimsRefresh(null,
								function (token) {
								mbaasRef.tokens[_providerName] = token.claims_token.value;
								logger.log("### AuthService::getBackendToken fetching refresh successfull. Calling success callback");
								mbaasRef.currentBackEndToken = token.provider_token;
								kony.mbaas.verifyAndCallClosure(successCallback, token.provider_token);
							},
								function (error) {
								logger.log("### AuthService::getBackendToken fetching refresh failed. Calling failure callback");
								kony.mbaas.verifyAndCallClosure(failureCallback, error);
							});
						} else {
							logger.log("### AuthService::getBackendToken present token is valid/doesn't have expiry time. Calling success callback");
							mbaasRef.currentBackEndToken = val.provider_token;
							kony.mbaas.verifyAndCallClosure(successCallback, val.provider_token);
						}
					} else {
						logger.log("### AuthService::getBackendToken failed for find info for key " + dsKey + "in database. calling failure callback");
						kony.mbaas.verifyAndCallClosure(failureCallback, null);
					}
				}
			};
			/**
			* Get profile callback method.
			* @callback getProfileSuccessCallback
			* @param {object} profile - Profile object
			*/

			/**
			* Get profile callback method.
			* @callback getProfileFailureCallback
			*/
			/**
			 * Get profile.
			 * @param {boolean} fromserver - Flag to force fetch from server only.
			 * @param {getProfileSuccessCallback} successCallback  - Callback method on success
			 * @param {getProfileFailureCallback} failureCallback - Callback method on failure
			 */
			this.getProfile = function (fromserver, successCallback, failureCallback) {
				if (fromserver && fromserver == true) {
					_claimsRefresh(null,
						function (token) {
						mbaasRef.tokens[_providerName] = token;
						kony.mbaas.verifyAndCallClosure(successCallback, token.profile);
					},
						failureCallback)
				} else {
					if (mbaasRef.tokens[_providerName]) {
						var val = mbaasRef.tokens[_providerName]
						kony.mbaas.verifyAndCallClosure(successCallback, val.profile);
					} else {
						kony.mbaas.verifyAndCallClosure(failureCallback, null);
					}
				}
			};
			/**
			 * Get the provider name.
			 * @returns {string} Provider name.
			 */
			this.getProviderName = function () {
				return _providerName;
			};
			/**
			 * Get the provider type.
			 * @returns {string} Provider type.
			 */
			this.getProviderType = function () {
				return _type;
			};
			/**
			 * Method to refresh the claims token.
			 * @private
			 */
			var _claimsRefresh = function (options, success, failure) {
				logger.log("### AuthService::_claimsRefresh fetching claims from server for provider " + _providerName);
				var value = mbaasRef.tokens[_providerName];
				var refreshToken = null;
				if (value) {
					refreshToken = value.refresh_token;
				}
				var _url = _serviceUrl + "/claims";
				if (options && options.requestParams != null) {
					_url = _url + "?"
						for (var i in options.requestParams) {
							if (options.requestParams.hasOwnProperty(i) && typeof(i) !== 'function') {
								_url = _url + (i + "=" + options.requestParams[i] + "&");
							}
						}
						_url = stripTrailingCharacter(_url, "&");
				}
				if (refreshToken) {
					logger.log("### AuthService::_claimsRefresh making POST request to claims endpoint");
					networkProvider.post(_url, {}, {
						"Authorization" : refreshToken
					},
						function (data) {
						logger.log("### AuthService::_claimsRefresh Fetching claims succcessfull");
						mbaasRef.tokens[_providerName] = data;
						logger.log("### AuthService::_claimsRefresh saved locally. Calling success callback");
						kony.mbaas.verifyAndCallClosure(success, data);
					},
						function (xhr, status, err) {
						logger.log("### AuthService::_claimsRefresh fetching claims failed. Calling failure callback");
						kony.mbaas.verifyAndCallClosure(failure, err);
					});
				} else {
					logger.log("### AuthService::_claimsRefresh no refreshtoken found. calling failure callback");
					kony.mbaas.verifyAndCallClosure(failure, null);
				}
			};
		};
/**
 * Method to create the integration service instance with the provided service name.
 * @param {string} serviceName - Name of the service
 * @returns {IntegrationService} Integration service instance
 */
kony.mbaas.prototype.getIntegrationService = function (serviceName) {
	if(!kony.mbaas.isInitialized){
		throw new Exception(Errors.INIT_FAILURE, "Please call init before invoking this service");
	}
	if(!this.currentClaimToken){
		throw new Exception(Errors.AUTH_FAILURE, "Please call login in Identity Service before invoking this service");
	}
	var logger = new mbaasLogger();
	var integrationService = null;
	if(this.integsvc != null){
		if(this.integsvc[serviceName] != null){
			logger.log("found integration service" + this.integsvc[serviceName]);
			return new IntegrationService(this, serviceName);
		}
	
	}
	
	throw new Exception(Errors.INTEGRATION_FAILURE, "Invalid serviceName");
		
};
/**
 * Should not be called by the developer.
 * @class
 * @classdesc Integration service instance for invoking the integration services.
 */
function IntegrationService(mbaasRef, serviceName) {
			var logger = new mbaasLogger();
			var dataStore = new mbaasDataStore();
			var homeUrl = mbaasRef.integsvc[serviceName];
			var networkProvider = new mbaasNetworkProvider();
			if (homeUrl == undefined || serviceName == undefined) {
				throw new Exception(Errors.INIT_FAILURE, "Invalid homeUrl and serviceName");
			}
			homeUrl = stripTrailingCharacter(homeUrl, "/");
			var sessionID = dataStore.getItem("konyMbaasUUID");
			var requestData = kony.mbaas.getPayload(mbaasRef);
			requestData.sessionID = sessionID;
			

			this.getUrl = function () {
				return homeUrl;
			};
			/**
			* Integration service success callback method.
			* @callback integrationSuccessCallback
			* @param {json} response - Integration service response
			*/

			/**
			* Integration service failure callback method.
			* @callback integrationFailureCallback
			* @param {json} error - Error information
			*/
			/**
			 * invoke the specified operation 
			 * @param {string} operationName - Name of the operation
			 * @param {object} data - Input data to the operation
			 * @param {integrationSuccessCallback} successCallback  - Callback method on success
			 * @param {integrationFailureCallback} failureCallback - Callback method on failure
			 */
			this.invokeOperation = function (operationName, data, successCallback, failureCallback, optional) {
				for (var key in data) {
					requestData[key] = data[key];
				}
				requestData.svcid = operationName;
				var token;
				for (var i in mbaasRef.tokens) {
					if (mbaasRef.tokens.hasOwnProperty(i) && typeof(i) !== 'function') {
						token = mbaasRef.tokens[i];
						break;
					}
				}
				logger.log("The token after processing is" + JSON.stringify(token));

				if (optional !== undefined && optional !== null && optional.providerName !== undefined) {
					token = mbaasRef.tokens[optional.providerName];
				}
				
				logger.log("request data is " + JSON.stringify(requestData));

				networkProvider.post(homeUrl + "/" + operationName,
					requestData, {
					"Content-Type" : "application/x-www-form-urlencoded",
					"X-Kony-Authorization" : token.claims_token.value
				},
					function(res){
						kony.mbaas.verifyAndCallClosure(successCallback, res);
					},
					function (xhr, status, err) {
					kony.mbaas.verifyAndCallClosure(failureCallback, err);
				});
			};

		};


stripTrailingCharacter = function (str, character) {
	if (str.substr(str.length - 1) == character) {
		return str.substr(0, str.length - 1);
	}
	return str;
};

var Constants = {
	APP_KEY_HEADER : "X-Kony-App-Key",
	APP_SECRET_HEADER : "X-Kony-App-Secret",
	AUTHORIZATION_HEADER : "Authorization"
};

var Errors = {
	INIT_FAILURE : "INIT_FAILURE",
	DATA_STORE_EXCEPTION : "DATASTORE_FAILURE",
	AUTH_FAILURE: "AUTH_FAILURE",
	INTEGRATION_FAILURE: "INTEGRATION_FAILURE",
	MESSAGING_FAILURE: "MESSAGING_FAILURE",
	SYNC_FAILURE: "SYNC_FAILURE",
	METRICS_FAILURE: "METRICS_FAILURE"
};
kony.mbaas.prototype.enableDebug = function () {
	kony.mbaas.isDebugEnabled = true;
}

kony.mbaas.prototype.disableDebug = function () {
	kony.mbaas.isDebugEnabled = false;
}
//to be removed
var hashCode = function (str) {
	var hash = 0;
	if (str.length == 0)
		return hash;
	for (i = 0; i < str.length; i++) {
		cha = str.charCodeAt(i);
		hash = ((hash << 5) - hash) + cha;
		hash = hash & hash;
	}
	return hash;
};

function Exception(name, message) {
	alert(name + ": " + message);
	return {
		code : name,
		message : message
	};
};

kony.mbaas.verifyAndCallClosure = function(closure, params){
	if(typeof(closure) === 'function'){
		closure(params);
	}
	else{
		var logger  = new mbaasLogger();
		logger.log("invalid callback");
	}
}

/**
 * Method to create the messaging service instance.
 * @returns {MessagingService} Messaging service instance
 */
kony.mbaas.prototype.getMessagingService = function () {
	if(!kony.mbaas.isInitialized){
		throw new Exception(Errors.INIT_FAILURE, "Please call init before invoking this service");
	}
	return new MessagingService(this);
}

/**
 * Should not be called by the developer.
 * @class
 * @classdesc Messaging service instance for invoking the Messaging services.
 *@param reference to mbaas object
 */
function MessagingService(mbaasRef) {
	
	var homeUrl = mbaasRef.messagingsvc.url;
	var KSID;
	var appId = mbaasRef.messagingsvc.appId;
	var logger = new mbaasLogger();
	var networkProvider = new mbaasNetworkProvider();
	var dsKey = homeUrl + ":KMS:AppId";

	this.getUrl = function () {
		return homeUrl;
	};

	this.setKSID = function (ksid) {
		mbaasRef.getDataStore().setItem(dsKey, ksid);
		KSID = ksid;
	};

	this.getKSID = function () {
		if (!KSID) {
			KSID = mbaasRef.getDataStore().getItem(dsKey);
		}
		return KSID;
	};

	this.setKmsAppId = function (id) {
		appId = id;
	};

	this.getKmsAppId = function () {
		return appId;
	};
	/**
	* register success callback method.
	* @callback registerSuccessCallback
	* @param {json} response - register response
	*/

	/**
	* Register service failure callback method.
	* @callback registerFailureCallback
	* @param {json} error - Error information
	*/
	/**
	 * register to messaging service
	 * @param {string} osType - Type of the operating system
	 * @param {string} deviceId - Device Id
	 * @param {string} pnsToken - Token value
	 * @param {registerSuccessCallback} successCallback - Callback method on success
	 * @param {registerFailureCallback} failureCallback - Callback method on failure
	 */
	this.register = function (osType, deviceId, pnsToken, email, successCallback, failureCallback) {
		if(typeof(pnsToken) === 'undefined' || pnsToken === null){
			throw new Exception(Errors.MESSAGING_FAILURE, "Invalid pnsToken/sId. Please check your messaging provider");
		}
		if(typeof(osType) === 'undefined' || osType === null){
			throw new Exception(Errors.MESSAGING_FAILURE, "Invalid osType.");
		}
		if(typeof(deviceId) === 'undefined' || deviceId === null){
			throw new Exception(Errors.MESSAGING_FAILURE, "Invalid deviceId.");
		}
		if(typeof(email) === 'undefined' || email === null){
			throw new Exception(Errors.MESSAGING_FAILURE, "Invalid email.");
		}
		var uri = homeUrl + "/subscribers";
		jsonParam = {
			"subscriptionService" : {
				"subscribe" : {
					"sid" : pnsToken,
					"appId" : this.getKmsAppId(),
					"ufid" : email,
					"osType" : osType,
					"deviceId" : deviceId
				}
			}
		};
		logger.log(JSON.stringify(jsonParam));
		var headers = {"Content-Type":"application/json"};
		var payload = {postdata: JSON.stringify(jsonParam)};
		networkProvider.post(uri,
			payload,
			headers,
			function (data) {
			KSID = data.id;
			mbaasRef.getDataStore().setItem(dsKey, KSID);
			logger.log("Device registered to KMS with KSID:" + KSID);
			kony.mbaas.verifyAndCallClosure(successCallback, data);
		},
			function (data, status, error) {

			logger.log("ERROR: Failed to register device for KMS");
			var errorObj = {};
			errorObj.data = data;
			errorObj.status = status;
			errorObj.error = error;
			kony.mbaas.verifyAndCallClosure(failureCallback, errorObj);
		});
	};
	/**
	* unregister success callback method.
	* @callback unregisterSuccessCallback
	*/

	/**
	* unregister service failure callback method.
	* @callback unregisterFailureCallback
	*/
	/**
	 * unregister to messaging service
	 * @param {unregisterSuccessCallback} successCallback - Callback method on success
	 * @param {unregisterFailureCallback} failureCallback - Callback method on failure
	 */
	this.unregister = function (successCallback, failureCallback) {
		var uri = homeUrl + "/subscribers"
		var sub = { "ksid":this.getKSID()};
		var inp = {"subscriptionService":{"unsubscribe":sub}};
		var headers = {"Content-Type":"application/json"};
		var payload = {postdata:JSON.stringify(inp)}
		logger.log("unsubscribe uri:" + uri);
		mbaasRef.getDataStore().removeItem(dsKey);
		networkProvider.post(uri,
			payload,
			headers,
			function (data) {
			kony.mbaas.verifyAndCallClosure(successCallback, data);
		},
			function (data, status, error) {

			logger.log("ERROR: Failed to unregister device for KMS");
			var errorObj = {};
			errorObj.data = data;
			errorObj.status = status;
			errorObj.error = error;
			kony.mbaas.verifyAndCallClosure(failureCallback, errorObj);
		});
	};
	/**
	* Fetch all messages success callback method.
	* @callback fetchAllMessagesSuccessCallback
	* @param {json} response - Fetch all messages response
	*/

	/**
	* Fetch all messages service failure callback method.
	* @callback fetchAllMessagesFailureCallback
	* @param {json} error - Error information
	*/
	/**
	 * Fetch all messages
	 * @param {fetchAllMessagesSuccessCallback} successCallback - Callback method on success
	 * @param {fetchAllMessagesFailureCallback} failureCallback - Callback method on failure
	 */
	this.fetchAllMessages = function (startIndex, pageSize, successCallback, failureCallback) {
		var uri = homeUrl + "/messages/fetch";

		var data = {
			"ksid" : this.getKSID(),
			"startElement" : startIndex,
			"elementsPerPage" : pageSize
		};
		var headers = {"Content-Type":"application/json"};
		var payload = {postdata:JSON.stringify(data)};

		networkProvider.post(uri, payload, headers, successCallback, failureCallback);
	};
	/**
	* Update location service success callback method.
	* @callback updateLocationSuccessCallback
	* @param {json} response - Update location response
	*/

	/**
	* Update location service failure callback method.
	* @callback updateLocationFailureCallback
	* @param {json} error - Error information
	*/
	/**
	 * Update the location
	 * @param {string} latitude - Latitude value
	 * @param {string} longitude - Longitude value
	 * @param {string} locationName - Location name
	 * @param {updateLocationSuccessCallback} successCallback - Callback method on success
	 * @param {updateLocationFailureCallback} failureCallback - Callback method on failure
	 */
	this.updateGeoLocation= function (latitude, longitude, locationName, successCallback, failureCallback) {
		if(typeof(latitude) === 'undefined' || latitude === null){
			throw new Exception(MESSAGING_FAILURE, "invalid latitude paramter value");
		}
		if(typeof(longitude) === 'undefined' || longitude === null){
			throw new Exception(MESSAGING_FAILURE, "invalid longitude paramter value");
		}
		if(typeof(locationName) === 'undefined' || locationName === null){
			throw new Exception(MESSAGING_FAILURE, "invalid locationName paramter value");
		}

		var uri = homeUrl + "/location";
		var data = {
			"ksid" : this.getKSID(),
			"latitude" : latitude,
			"locname" : locationName,
			"longitude" : longitude
		};
		var headers = {"Content-Type":"application/json"};		
		var payload = {postdata:JSON.stringify(data)};
		logger.log("updateLocation payload: " + JSON.stringify(payload));
		networkProvider.post(uri, payload, headers, successCallback, failureCallback);
	};
	/**
	* Mark meesage as read service success callback method.
	* @callback markReadSuccessCallback
	* @param {json} response - Mark meesage as read service response
	*/
	/**
	* Mark meesage as read service failure callback method.
	* @callback markReadFailureCallback
	* @param {json} error - Error information
	*/
	/**
	 * Mark the message as read for a given message id
	 * @param {string} messageId - Message id
	 * @param {markReadSuccessCallback} successCallback - Callback method on success
	 * @param {markReadFailureCallback} failureCallback - Callback method on failure
	 */
	this.markMessageRead = function (fetchId, successCallback, failureCallback) {
		if(typeof(fetchId) === 'undefined' || fetchId === null){
			throw new Exception(MESSAGING_FAILURE, "invalid fetchId paramter value");
		}
		var headers = {};
		headers["X-HTTP-Method-Override"] = "get";
		headers["Content-Type"] = "application/json";
		var uri = homeUrl + "/messages/open/" + fetchId;
		networkProvider.post(uri, null, headers, successCallback, failureCallback);

	};
	/**
	* Message content service success callback method.
	* @callback messageContentSuccessCallback
	* @param {json} response - Message content service response
	*/
	/**
	* Message content service failure callback method.
	* @callback messageContentFailureCallback
	* @param {json} error - Error information
	*/
	/**
	 * Fetches the message conetent for a given message id
	 * @param {string} messageId - Message id
	 * @param {messageContentSuccessCallback} successCallback - Callback method on success
	 * @param {messageContentFailureCallback} failureCallback - Callback method on failure
	 */
	this.fetchMessageContent = function (fetchId, successCallback, failureCallback) {
		if(typeof(fetchId) === 'undefined' || fetchId === null){
			throw new Exception(MESSAGING_FAILURE, "invalid fetchId paramter value");
		}		
		var uri = homeUrl + "/messages/content/" + fetchId;
		networkProvider.post(uri, null, null, successCallback, failureCallback);
	};
};

//stub method
kony.mbaas.initiateSession = function () {
	return;
}
/**
 * Method to create the sync service instance.
 * @returns {SyncService} sync service instance
 */
kony.mbaas.prototype.getSyncService = function () {
	if(!kony.mbaas.isInitialized){
		throw new Exception(Errors.INIT_FAILURE, "Please call init before invoking this service");
	}
	var mbaasSync = sync;
	var SyncProvider = this.sync;
	var claimToken = this.currentClaimToken;
	var tempFunction = sync.startSession;
	function tempSession(config){
		if(typeof(config) === 'undefined' || config === null){
			throw new Exception(Errors.SYNC_FAILURE, "invalid startSession config object");
		}
		if(typeof(claimToken) === 'undefined' || claimToken === null){
			throw new Exception(Errors.SYNC_FAILURE, "invalid claims token.Please call Identity Service Login");
		}
		var syncServiceUrl;
		var syncServiceAppid;
		for(var Provider in SyncProvider){
			syncServiceAppid = Provider;
			syncServiceUrl = SyncProvider[Provider] +"/";
		}

		config.serverurl = syncServiceUrl;
		config.appid = syncServiceAppid;
		config.authtoken = claimToken;
		tempFunction(config);
	}
	mbaasSync.startSession = tempSession;
	
	return mbaasSync;
}



 

function OAuthHandler(serviceUrl, providerName, callback,url) {
	var popBasic ={id:"popUp", skin:null, isModal:false, transparencyBehindThePopup:80};
	var popLayout ={containerWeight:100, padding:[5,5,5,5], "paddingInPixel": true};
	var popPSP ={};
					//to do.. this is a workaround for android browser issue.. need to refactor this code
	var browserSF = new kony.ui.Browser({
							"id": "browserSF",
							"text": "Browser",
							"isVisible": true,
							"detectTelNumber": true,
							"screenLevelWidget": false,
							"enableZoom": false
						}, {
							"margin": [0, 0, 0, 0],
							"marginInPixel": true,
							"paddingInPixel": true,
							"containerWeight": 100
						}, {});
	//browserSF.handleRequest = function(){};
	var popUp = new kony.ui.Popup(popBasic, popLayout, popPSP);
	popUp.add(browserSF);
	popUp.show();

	var urlConf = {
		URL : serviceUrl + "/oauth2/login?provider=" + providerName,
		requestMethod : constants.BROWSER_REQUEST_METHOD_GET
	};
	browserSF.requestURLConfig = urlConf;
	browserSF.handleRequest = handleRequestCallback;
	function handleRequestCallback(browserWidget, params) {

		var originalUrl = params["originalURL"];
		if (typeof(params.queryParams) !== "undefined" && typeof(params.queryParams.code) !== "undefined") {
			// make request for tokens
			popUp.dismiss();
			callback(url,{code:decodeURIComponent(params.queryParams.code)});
		}

	}
}


function mbaasLogger() {
	this.log = function (text) {
		if (kony.mbaas.isDebugEnabled) {
			kony.print(text);
		}
	}
}
function mbaasNetworkProvider() {
	var logger = new mbaasLogger();
	this.post = function (url, params, headers, successCallback, failureCallback) {

		function networkCallbackStatus(status, result) {
			if (status === 400) {
				logger.log("Response:" + JSON.stringify(result));
				if (result.opstatus !== null && result.opstatus !== undefined && result.opstatus !== 0) {
					failureCallback(result);
				} else {
					successCallback(result);
				}
			}
		}
	/*	if (headers === undefined || headers === null) {
			headers = {}
		} 
		if (headers["Content-Type"] === null || headers["Content-Type"] === undefined) {
			//headers["Content-Type"] = "application/json"; //setting to default header
			//headers["Content-Type"] = "application/x-www-form-urlencoded"; //setting to default header
		}*/
		// headers = JSON.stringify(headers);

		if (params === undefined || params === null) {
			params = {};
		}
		if(typeof(headers) !== 'undefined' && headers !== null){
			params.httpheaders = headers;
		}
		
		logger.log("Hitting " + url + " with params " + JSON.stringify(params));
		kony.net.invokeServiceAsync(url, params, networkCallbackStatus, null);
	};
};

function mbaasDataStore() {
	var logger = new mbaasLogger();
	this.setItem = function (key, value) {
		logger.log("Setting item:" + value + " with key:" + key);
		if (typeof(key) !== "string") {
			throw new KonyException(Errors.DATA_STORE_EXCEPTION, "Invalid Key");
		} else {
			try {
				key = key.replace(/\//gi, "");
				kony.store.setItem(key, value);
			} catch (e) {
				logger.log("Failed to set item in dtastore:" + e);
			}
		}
	};

	this.getItem = function (key) {
		logger.log("Getting item for key:" + key);
		if (typeof(key) !== "string") {
			throw new KonyException(Errors.DATA_STORE_EXCEPTION);
		} else {
			key = key.replace(/\//gi, "");
			var value = kony.store.getItem(key);
			if (value === null || value === undefined) {
				logger.log("No value found with key:" + key);
				return null;
			} else {
				return value;
			}
		}
	};

	this.removeItem = function (key) {
		logger.log("Removing item for key:" + key);
		if (typeof(key) !== "string") {
			throw new KonyException(Error.DATA_STORE_EXCEPTION);
		} else {
			key = key.replace(/\//gi, "");
			kony.store.removeItem(key); //If no item with that key exists, the method does not perform any action. Thus no need to check for key availablity.
		}
	};

	this.destroy = function () {
		logger.log("Destroying data store for this app");
		kony.store.clear();
	};

	this.getAllItems = function () {
		logger.log("Getting all item from data store");
		var items = {};
		var len = kony.store.length(); //get key length
		for (var i = 0; i < len; i++) {
			var key = kony.store.key(i); //get ith key
			var value = kony.store.getItem(key); //get value
			items[key] = value; //prepare itemset
		}
		return items;
	}
};

//#ifdef iphone
	//#define KONYSYNC_IOS
//#endif
//#ifdef bb
	//#define KONYSYNC_BB
//#endif
//#ifdef bb10
	//#define KONYSYNC_BB10
//#endif
//#ifdef winmobile
	//#define KONYSYNC_WINDOWS
//#endif
//#ifdef winmobile6x
	//#define KONYSYNC_WINDOWS
//#endif
//#ifdef winphone8
	//#define KONYSYNC_WINDOWS
//#endif
//#ifdef android
	//#define KONYSYNC_ANDROID
//#endif
//#ifdef j2me
	//#define KONYSYNC_J2ME
//#endif

//#ifdef ipad
	//#define KONYSYNC_IOS
//#endif
//#ifdef tabrcandroid
	//#define KONYSYNC_ANDROID
//#endif
//#ifdef playbook
	//#define KONYSYNC_WINDOWS
//#endif
//#ifdef spaipad
	//#define KONYSYNC_IOS
//#endif
//#ifdef spatabandroid
	//#define KONYSYNC_ANDROID
//#endif
//#ifdef spaplaybook
	//#define KONYSYNC_WINDOWS
//#endif
//#ifdef windows8
	//#define KONYSYNC_WINDOWS
//#endif
//#ifdef spatabwindows
	//#define KONYSYNC_WINDOWS
//#endif

//#ifdef desktop_kiosk
	//#define KONYSYNC_WINDOWS
//#endif
//#ifdef desktopweb
	//#define KONYSYNC_WINDOWS
//#endif


//#ifdef iphone
	//#define KONYSYNC_MOBILE
//#endif
//#ifdef bb
	//#define KONYSYNC_MOBILE
//#endif
//#ifdef bb10
	//#define KONYSYNC_MOBILE
//#endif
//#ifdef winmobile
	//#define KONYSYNC_MOBILE
//#endif
//#ifdef winmobile6x
	//#define KONYSYNC_MOBILE
//#endif
//#ifdef winphone8
	//#define KONYSYNC_MOBILE
//#endif
//#ifdef android
	//#define KONYSYNC_MOBILE
//#endif
//#ifdef j2me
	//#define KONYSYNC_MOBILE
//#endif
//#ifdef symbian
	//#define KONYSYNC_MOBILE
//#endif

//#ifdef ipad
	//#define KONYSYNC_TAB
//#endif
//#ifdef tabrcandroid
	//#define KONYSYNC_TAB
//#endif
//#ifdef playbook
	//#define KONYSYNC_TAB
//#endif
//#ifdef spaipad
	//#define KONYSYNC_TAB
//#endif
//#ifdef spatabandroid
	//#define KONYSYNC_TAB
//#endif
//#ifdef spaplaybook
	//#define KONYSYNC_TAB
//#endif
//#ifdef windows8
	//#define KONYSYNC_TAB
//#endif
//#ifdef spatabwindows
	//#define KONYSYNC_TAB
//#endif

//#ifdef desktop_kiosk
	//#define KONYSYNC_DESKTOP
//#endif
//#ifdef desktopweb
	//#define KONYSYNC_DESKTOP
//#endif

kony.mbaas.getPayload = function(mbaasRef){
	var payload = {};
	payload.os = kony.os.deviceInfo().version + "";
    payload.dm = kony.os.deviceInfo().model;
    payload.did = kony.os.deviceInfo().deviceid;
    payload.ua = kony.os.userAgent();
	payload.aid = mbaasRef.mainRef.baseId;
	payload.aname = mbaasRef.mainRef.name;
	payload.chnl = kony.mbaas.getChannelType();
	payload.plat = kony.mbaas.getPlatformName();
	payload.aver = appConfig.appVersion;
	payload.atype = "kony-sdk";
	return payload;
}

kony.mbaas.getChannelType = function(){
	var returnVal = "";
	//#ifdef KONYSYNC_MOBILE
		returnVal = "mobile";
	//#endif
	//#ifdef KONYSYNC_TAB
		returnVal = "tablet";
	//#endif
	//#ifdef KONYSYNC_DESKTOP
		returnVal = "desktop";
	//#endif
	return returnVal;
};

kony.mbaas.getPlatformName = function(){
	var returnVal = "";
	//#ifdef KONYSYNC_IOS
		returnVal = "ios";
	//#endif
	//#ifdef KONYSYNC_WINDOWS
		returnVal = "windows";
	//#endif
	//#ifdef KONYSYNC_ANDROID
		returnVal = "android";
	//#endif
	//#ifdef KONYSYNC_J2ME
		returnVal = "j2me";
	//#endif
	//#ifdef KONYSYNC_BB
		returnVal = "blackberry";
	//#endif
	return returnVal;
};

kony.mbaas.invokeMbaasServiceFromKonyStudio = function(url, inputParam, serviceID, operationID ,callBack){
	var currentInstance = kony.mbaas.getCurrentInstance();
	if(!currentInstance){
		throw new Exception(Errors.INIT_FAILURE, "Please call init before invoking this service");
	}
	var integrationService = currentInstance.getIntegrationService(serviceID);

	integrationService.invokeOperation(operationID, inputParam, function(res){
		if(typeof(callBack) === 'function'){
			callBack(400,res);
		}

	}, function(res){
		if(typeof(callBack) === 'function'){
			callBack(400,res);
		}
	});
}
